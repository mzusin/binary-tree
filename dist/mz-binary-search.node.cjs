/*
https://github.com/mzusin/binary-search
MIT License      
Copyright (c) 2023-present, Miriam Zusin       
*/
var h=Object.defineProperty;var d=Object.getOwnPropertyDescriptor;var a=Object.getOwnPropertyNames;var T=Object.prototype.hasOwnProperty;var f=Math.pow;var I=(t,r)=>{for(var n in r)h(t,n,{get:r[n],enumerable:!0})},m=(t,r,n,e)=>{if(r&&typeof r=="object"||typeof r=="function")for(let s of a(r))!T.call(t,s)&&s!==n&&h(t,s,{get:()=>r[s],enumerable:!(e=d(r,s))||e.enumerable});return t};var N=t=>m(h({},"__esModule",{value:!0}),t);var R={};I(R,{bfsWithLevel:()=>y,bfsWithQueue:()=>S,convertSortedArrayToBalancedBSTIterative:()=>M,convertSortedArrayToBalancedBSTRecursive:()=>D,countCompleteBinaryTreeNodes:()=>p,getCompleteBinaryTreeDepth:()=>i,getDepth:()=>c,inorderTraversalIterative:()=>v,inorderTraversalRecursive:()=>g,postorderTraversalIterative:()=>w,postorderTraversalIterativeWith2Stacks:()=>x,postorderTraversalRecursive:()=>b,preorderTraversalIterative:()=>B,preorderTraversalRecursive:()=>k});module.exports=N(R);var g=t=>{let r=[],n=e=>{e&&(n(e.left),r.push(e.val),n(e.right))};return n(t),r},v=t=>{if(!t)return[];let r=[],n=[],e=t;for(;e||n.length>0;){for(;e;)n.push(e),e=e.left;e=n.pop(),r.push(e.val),e=e.right}return r},b=t=>{let r=[],n=e=>{e&&(n(e.left),n(e.right),r.push(e.val))};return n(t),r},x=t=>{if(!t)return[];let r=[],n=[t],e=[];for(;n.length>0;){let s=n.pop();e.push(s),s!=null&&s.left&&n.push(s.left),s!=null&&s.right&&n.push(s.right)}for(;e.length>0;){let s=e.pop();r.push(s.val)}return r},w=t=>{if(!t)return[];let r=[t],n=[];for(;r.length>0;){let e=r.pop();e.left&&r.push(e.left),e.right&&r.push(e.right),n.unshift(e.val)}return n},k=t=>{let r=[],n=e=>{e&&(r.push(e.val),n(e.left),n(e.right))};return n(t),r},B=t=>{if(!t)return[];let r=[],n=[t];for(;n.length>0;){let e=n.pop();r.push(e.val),e.right&&n.push(e.right),e.left&&n.push(e.left)}return r},S=t=>{if(!t)return[];let r=[t],n=[];for(;r.length>0;){let e=r.shift();n.push(e.val),e.left&&r.push(e.left),e.right&&r.push(e.right)}return n},y=t=>{if(!t)return[];let r=[t],n=[],e=0;for(;r.length>0;){let s=r.length;for(;s>0;){let o=r.shift();n.push(o.val),o.left&&r.push(o.left),o.right&&r.push(o.right),s--}console.log(e),e++}return n},c=t=>{if(!t)return 0;let r=c(t.left),n=c(t.right);return 1+Math.max(r,n)};var D=t=>{if(!t||t.length<=0)return;let r=(n,e)=>{if(n>e)return;let s=Math.floor((e+n)/2);return{left:r(n,s-1),val:t[s],right:r(s+1,e)}};return r(0,t.length-1)},M=t=>{if(!t||t.length<=0)return;let r=Math.floor(t.length/2),n={val:t[r]},e=[[n,0,r-1],[n,r+1,t.length-1]];for(;e.length>0;){let[s,o,l]=e.shift();if(o>l)break;r=Math.floor((o+l)/2);let u={val:t[r]};u.val<=s.val?s.left=u:s.right=u,e.push([u,o,r-1]),e.push([u,r+1,l])}return n};var i=t=>t?1+i(t.left):0,p=t=>{if(!t)return 0;let r=i(t.left),n=i(t.right);return r===n?f(2,r)+p(t.right):f(2,n)+p(t.left)};0&&(module.exports={bfsWithLevel,bfsWithQueue,convertSortedArrayToBalancedBSTIterative,convertSortedArrayToBalancedBSTRecursive,countCompleteBinaryTreeNodes,getCompleteBinaryTreeDepth,getDepth,inorderTraversalIterative,inorderTraversalRecursive,postorderTraversalIterative,postorderTraversalIterativeWith2Stacks,postorderTraversalRecursive,preorderTraversalIterative,preorderTraversalRecursive});
